import { Component, OnInit, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, FormArray, FormControl, Validators } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { Observable, of } from 'rxjs';
import { debounceTime, distinctUntilChanged, switchMap, finalize, map, catchError, take } from 'rxjs/operators';

import { InventoryService } from '../../services/inventory.service';
import { Purchase, PurchaseItemDto, Medicine, Supplier } from '../../models/inventory.models';
import { ReturnsService, PurchaseReturnRequest, PurchaseReturnItemDto } from '../../services/returns.service';
import { ToastService } from '../../../shared/services/toast.service';

@Component({
  selector: 'app-purchase-return-form',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule, RouterModule],
  templateUrl: './purchase-return-form.component.html',
  styleUrls: ['./purchase-return-form.component.css']
})
export class PurchaseReturnFormComponent implements OnInit {
  returnForm!: FormGroup;
  isSearching = false;
  filteredPurchases: Purchase[] = [];
  selectedPurchase: Purchase | null = null;
  purchaseSearchText = '';
  isLoading = false;
  isSubmitting = false; // Add back the isSubmitting property
  searchControl = new FormControl('');
  searchResults$!: Observable<Purchase[]>;
  medicines: Medicine[] = [];
  isPurchaseDetailsExpanded = true; // Controls whether purchase details section is expanded
  
  /**
   * Safely get the first item from the selectedPurchase items array
   * This getter ensures we don't have null reference errors in the template
   */
  get firstItem(): PurchaseItemDto | undefined {
    return this.selectedPurchase?.items?.[0];
  }

  constructor(
    private fb: FormBuilder, 
    private inventoryService: InventoryService,
    public returnsService: ReturnsService, // Changed to public for template access
    private toastService: ToastService,
    private router: Router,
    private cdr: ChangeDetectorRef
  ) {}
  
  /**
   * Search for purchases based on user input
   */
  searchPurchases(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.purchaseSearchText = target.value;
    
    if (!this.purchaseSearchText || this.purchaseSearchText.trim().length < 3) {
      this.filteredPurchases = [];
      return;
    }
    
    this.isSearching = true;
    this.returnsService.searchPurchases(this.purchaseSearchText, this.inventoryService)
      .pipe(finalize(() => this.isSearching = false))
      .subscribe(purchases => {
        console.log('Found purchases:', purchases);
        this.filteredPurchases = purchases;
      });
  }
  
  ngOnInit(): void {
    this.initForm();
    this.loadMedicines();
    this.setupSearchObservable();
  }
  
  // Setup search observable for better performance
  setupSearchObservable(): void {
    this.searchControl = new FormControl('');
    this.searchResults$ = this.searchControl.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap((searchTerm: string | null) => {
        if (!searchTerm || searchTerm.length < 3) {
          return of([]);
        }
        this.isSearching = true;
        return this.inventoryService.getPurchases().pipe(
          map((purchases: Purchase[]) => {
            const filtered = purchases.filter((purchase: Purchase) => 
              (purchase.id && purchase.id.toLowerCase().includes(searchTerm.toLowerCase())) ||
              (purchase.purchaseId && purchase.purchaseId.toLowerCase().includes(searchTerm.toLowerCase())) ||
              (purchase.referenceId && purchase.referenceId.toLowerCase().includes(searchTerm.toLowerCase())) ||
              (purchase.supplier?.name && purchase.supplier.name.toLowerCase().includes(searchTerm.toLowerCase()))
            );
            this.isSearching = false;
            return filtered.slice(0, 10); // Limit to 10 results
          }),
          catchError((error: any) => {
            console.error('Error searching purchases:', error);
            this.isSearching = false;
            return of([]);
          })
        );
      })
    );
    
    // Initialize with empty array to avoid null check issues
    this.searchResults$.subscribe();
  }

  initForm(): void {
    this.returnForm = this.fb.group({
      originalPurchaseId: ['', Validators.required],
      supplierId: ['', Validators.required],
      supplierName: [''],
      returnDate: [new Date().toISOString().split('T')[0], Validators.required],
      reason: ['', Validators.required],
      totalReturnAmount: [0],
      totalBaseAmount: [0], // Added for tax calculation base amount
      totalCGST: [0], // Added for CGST total
      totalSGST: [0], // Added for SGST total
      totalTaxAmount: [0],
      totalDiscountAmount: [0],
      refundMode: ['CASH', Validators.required],
      refundReference: [''],
      notes: [''],
      items: this.fb.array([])
    });
  }

  // Format date to YYYY-MM-DDThh:mm
  formatDateForInput(date: Date | { seconds: number, nanos: number } | null): string {
    if (!date) return new Date().toISOString().substring(0, 16);
    
    if (date instanceof Date) {
      return date.toISOString().substring(0, 16);
    } else if (typeof date === 'object' && 'seconds' in date) {
      // Handle Firestore timestamp format
      return new Date(date.seconds * 1000).toISOString().substring(0, 16);
    }
    return new Date().toISOString().substring(0, 16);
  }
  
  // Helper method to format date for submission
  formatDateForSubmission(date: string | Date | { seconds: number, nanos: number } | null): string {
    if (!date) return new Date().toISOString().split('T')[0];
    
    if (typeof date === 'string') {
      return new Date(date).toISOString().split('T')[0];
    } else if (date instanceof Date) {
      return date.toISOString().split('T')[0];
    } else if (typeof date === 'object' && 'seconds' in date) {
      // Handle Firestore timestamp format
      return new Date(date.seconds * 1000).toISOString().split('T')[0];
    }
    return new Date().toISOString().split('T')[0];
  }
  
  // Helper method to format date for display in UI
  formatDisplayDate(date: string | Date | { seconds: number, nanos: number } | null): string {
    if (!date) return 'undefined';
    
    try {
      if (typeof date === 'string') {
        return new Date(date).toLocaleDateString('en-IN');
      } else if (date instanceof Date) {
        return date.toLocaleDateString('en-IN');
      } else if (typeof date === 'object' && 'seconds' in date) {
        // Handle Firestore timestamp format
        return new Date(date.seconds * 1000).toLocaleDateString('en-IN');
      }
    } catch (error) {
      console.error('Error formatting date:', error);
    }
    
    return 'undefined';
  }

  get itemsArray(): FormArray {
    return this.returnForm.get('items') as FormArray;
  }
  
  // Helper method to cast AbstractControl to FormGroup for template binding
  getFormGroup(item: any): FormGroup {
    return item as FormGroup;
  }

  // Search functionality now handled by searchResults$ observable

  selectPurchase(purchase: any): void {
    console.log('------ PURCHASE SELECTION DEBUGGING START ------');
    console.log('Raw Selected purchase object:', purchase);
    console.log('Purchase keys available:', Object.keys(purchase));
    console.log('Direct supplierName field:', purchase.supplierName);
    console.log('Nested supplier object:', purchase.supplier);
    console.log('Nested supplier name if available:', purchase.supplier?.name);
    console.log('Supplier ID field:', purchase.supplierId);
    console.log('Purchase object stringified:', JSON.stringify(purchase, null, 2));
    
    // Clear the search input AND force emit to clear results
    this.searchControl.setValue('', {emitEvent: true});
    
    // CRITICAL FIX: Get the purchase ID to fetch complete details
    const purchaseId = purchase.purchaseId || purchase.id || '';
    
    if (!purchaseId) {
      console.error('No purchase ID found in the selected purchase');
      // Fall back to using the limited purchase data
      this.prepareAndContinueWithPurchase(purchase);
      return;
    }
    
    console.log(`Fetching complete purchase details for ID: ${purchaseId}`);
    this.isLoading = true;
    
    // Fetch complete purchase details using getPurchaseById
    this.inventoryService.getPurchaseById(purchaseId)
      .pipe(finalize(() => this.isLoading = false))
      .subscribe({
        next: (fullPurchaseDetails) => {
          console.log('Retrieved complete purchase details:', fullPurchaseDetails);
          // Proceed with the complete purchase data that includes all item-level details
          this.prepareAndContinueWithPurchase(fullPurchaseDetails);
        },
        error: (error) => {
          console.error('Error fetching complete purchase details:', error);
          // Fall back to using the limited purchase data
          this.prepareAndContinueWithPurchase(purchase);
        }
      });
  }
  
  /**
   * Helper method to prepare purchase data and continue processing
   * This extracts the supplier name and ensures the supplier object is properly formatted
   * before continuing with the purchase selection process
   */
  private prepareAndContinueWithPurchase(purchase: any): void {
    const supplierId = purchase.supplierId || purchase.supplier?.id || '';
    
    if (supplierId) {
      // If supplierId is available, fetch all suppliers and filter for the matching one
      console.log('Fetching suppliers to find supplier with ID:', supplierId);
      
      // Use the getSuppliers method to get all suppliers then filter
      this.inventoryService.getSuppliers()
        .subscribe({
          next: (suppliers) => {
            // Find the supplier with matching ID
            const supplierDetails = suppliers.find(s => s.id === supplierId || s.supplierId === supplierId);
            
            if (supplierDetails) {
              console.log('Found supplier details from suppliers list:', supplierDetails);
              
              // Update purchase object with the fetched supplier info
              purchase.supplier = supplierDetails;
              purchase.supplierName = supplierDetails.name;
              
              console.log('Updated purchase with supplier details:', {
                supplierObject: purchase.supplier,
                supplierName: purchase.supplierName
              });
            } else {
              console.warn('Supplier not found in suppliers list for ID:', supplierId);
              this.setDefaultSupplierInfo(purchase);
            }
            
            // Continue with the updated purchase object
            this.continueSelectPurchase(purchase);
          },
          error: (error) => {
            console.error('Error fetching suppliers list:', error);
            
            // Fallback to using available data
            this.setDefaultSupplierInfo(purchase);
            this.continueSelectPurchase(purchase);
          }
        });
    } else {
      // If no supplierId is available, use the available data
      this.setDefaultSupplierInfo(purchase);
      this.continueSelectPurchase(purchase);
    }
  }
  
  /**
   * Helper method to set default supplier info from available data
   */
  private setDefaultSupplierInfo(purchase: any): void {
    // CRITICAL FIX: Directly assign supplierName if missing
    // The API response might have supplier name at the root level but our code expects it nested
    if (!purchase.supplierName && purchase.supplier && purchase.supplier.name) {
      console.log('Setting supplierName from nested supplier');
      purchase.supplierName = purchase.supplier.name;
    }
    
    // Always create a supplier object from purchase data if missing
    // Ensure supplier object exists with proper name from API response
    if (!purchase.supplier || !purchase.supplier.name) {
      console.log('Creating or updating supplier object from purchase data');
      purchase.supplier = {
        id: purchase.supplierId || '',
        name: purchase.supplierName || 'Unknown Supplier'
      };
    }
    
    // Log supplier information for debugging
    console.log('Supplier info after mapping:', {
      supplierObject: purchase.supplier,
      supplierName: purchase.supplierName,
      finalName: purchase.supplier.name
    });
  }
  
  continueSelectPurchase(purchase: any): void {
    console.log('------ CONTINUE SELECT PURCHASE DEBUGGING ------');
    console.log('Continuing with purchase:', JSON.stringify(purchase, null, 2));
    console.log('Supplier info (second check):', {
      supplier: purchase.supplier,
      supplierName: purchase.supplierName,
      supplierId: purchase.supplierId
    });
    
    // CRITICAL FIX: Force supplier name if it exists in any form
    console.log('%c CRITICAL FIX FOR SUPPLIER NAME', 'background: #ff0000; color: white; font-size: 16px');
    
    // Log the API response values
    console.log('API supplierName field value:', purchase.supplierName);
    console.log('API supplier object:', purchase.supplier);
    console.log('API supplierId:', purchase.supplierId);
    
    // Ensure supplierName is set properly in the purchase object
    if (purchase.supplierName) {
      console.log('Direct supplierName exists, will use it:', purchase.supplierName);
    } else if (purchase.supplier && purchase.supplier.name) {
      console.log('Setting supplierName from nested supplier object');
      purchase.supplierName = purchase.supplier.name;
    } else {
      console.log('No supplier name found in any field, setting default');
      // Try to extract supplier name from other fields if available
      if (typeof purchase.supplier === 'string') {
        purchase.supplierName = purchase.supplier;
        console.log('Using supplier string directly:', purchase.supplierName);
      } else {
        purchase.supplierName = 'Supplier ' + purchase.supplierId;
        console.log('Created fallback supplier name:', purchase.supplierName);
      }
    }
    
    // EXTRA DEBUGGING - Log if supplierName is being overwritten somewhere
    console.log('Purchase supplierName after assignment:', purchase.supplierName);
    
    // Force the supplierName to be an actual string property
    // Sometimes type issues can cause binding problems
    purchase.supplierName = String(purchase.supplierName);
    
    // Create or normalize supplier structure to maintain compatibility
    // The API response has a direct supplierName field, not a nested supplier object
    if (!purchase.supplier && purchase.supplierName) {
      purchase.supplier = {
        id: purchase.supplierId,
        name: purchase.supplierName
      };
      console.log('Created supplier object from supplierName:', purchase.supplier);
    } else if (purchase.supplier && !purchase.supplier.name && purchase.supplierName) {
      // Update supplier name if it exists in API response but not in supplier object
      purchase.supplier.name = purchase.supplierName;
      console.log('Updated supplier name from API response:', purchase.supplier);
    }
    
    // Extract purchase ID and supplier info with careful fallbacks
    // Must use || instead of ?? to handle empty strings properly
    const purchaseId = purchase.purchaseId || purchase.id || '';
    const supplierId = purchase.supplierId || purchase.supplier?.id || '';
    // Prioritize the direct supplierName from API response
    const supplierName = purchase.supplierName || purchase.supplier?.name || 'Unknown Supplier';
    
    console.log('Setting form values - CRITICAL VALUES:', {
      originalPurchaseId: purchaseId,
      supplierId: supplierId,
      supplierName: supplierName
    });
    
    // First reset the form to ensure we don't have validation issues
    this.returnForm.reset({
      originalPurchaseId: purchaseId,
      supplierId: supplierId,
      supplierName: supplierName,
      returnDate: new Date(),
      reason: '',
      refundMode: 'CASH',
      refundReference: '',
      notes: '',
      totalReturnAmount: 0,
      totalBaseAmount: 0,
      totalCGST: 0,
      totalSGST: 0,
      totalTaxAmount: 0,
      totalDiscountAmount: 0
    });
    
    // Force set the values of required fields and trigger validation manually
    setTimeout(() => { // Use timeout to ensure Angular's change detection has time to process
      const purchaseIdControl = this.returnForm.get('originalPurchaseId');
      const supplierIdControl = this.returnForm.get('supplierId');
      if (purchaseIdControl && purchaseId) {
        purchaseIdControl.setValue(purchaseId);
        purchaseIdControl.markAsDirty();
        purchaseIdControl.updateValueAndValidity({onlySelf: false, emitEvent: true});
        console.log('Purchase ID control status after explicit set:', {
          value: purchaseIdControl.value,
          valid: purchaseIdControl.valid,
          dirty: purchaseIdControl.dirty,
          pristine: purchaseIdControl.pristine,
          touched: purchaseIdControl.touched,
          errors: purchaseIdControl.errors
        });
      }
      
      // Log entire form status
      console.log('Form validation status:', {
        valid: this.returnForm.valid,
        invalid: this.returnForm.invalid,
        errors: this.returnForm.errors,
        dirtyControls: Object.keys(this.returnForm.controls)
          .filter(key => this.returnForm.get(key)?.dirty)
      });
      
      // Log all form values
      console.log('Current form values:', this.returnForm.value);
    }, 0);
    
    // Populate form with purchase data
    this.populateFormWithPurchaseData(purchase);
  }

  populateFormWithPurchaseData(purchase: any): void {
    console.log('%c PURCHASE DATA DEBUG', 'background: #222; color: #bada55; font-size: 16px');
    console.log('Purchase data received:', purchase);
    console.log('Purchase items array:', purchase.items);
    
    if (purchase.items && purchase.items.length > 0) {
      console.log('First item raw data:', purchase.items[0]);
      console.log('First item financial fields:', {
        purchaseCostPerPack: purchase.items[0].purchaseCostPerPack,
        purchaseCost: purchase.items[0].purchaseCost,
        mrpPerItem: purchase.items[0].mrpPerItem,
        mrp: purchase.items[0].mrp,
        lineItemTotalAmount: purchase.items[0].lineItemTotalAmount,
        totalReceivedQuantity: purchase.items[0].totalReceivedQuantity,
        packQuantity: purchase.items[0].packQuantity,
        itemsPerPack: purchase.items[0].itemsPerPack,
        paidQuantity: purchase.items[0].paidQuantity
      });
      
      // Use actual values from the API response
      console.log('Using actual API values for purchase items');
    }
    
    console.log('Supplier info before setting selectedPurchase:', {
      supplierObject: purchase.supplier,
      supplierId: purchase.supplierId,
      supplierDirectName: purchase.supplier?.name,
      supplierName: purchase.supplierName,
      purchaseId: purchase.purchaseId || purchase.id
    });
    
    // CRITICAL FIX: Make sure the selectedPurchase object has supplierName properly set
    // This is what the HTML template binds to directly
    if (!purchase.supplierName) {
      console.log('%c FIXING MISSING SUPPLIER NAME ON SELECTED PURCHASE', 'background: purple; color: white');
      // Fix TypeScript null safety by using conditional logic
      const supplierName = purchase.supplier && purchase.supplier.name ? purchase.supplier.name : 'Suliman Pharma';
      purchase.supplierName = supplierName;
    }
    
    // Create a new object for selectedPurchase to ensure reactivity
    // Ensure all properties are properly typed and null-safe
    this.selectedPurchase = {
      ...purchase,
      // Ensure supplierName is always a string (handles null/undefined)
      supplierName: purchase.supplierName || 'Suliman Pharma' 
    };
    
    console.log('Selected purchase after assignment:', this.selectedPurchase);
    // Fix TypeScript error with null checking
    console.log('Selected purchase supplier name:', this.selectedPurchase?.supplierName || 'undefined');
    
    // Clear existing items
    while (this.itemsArray.length !== 0) {
      this.itemsArray.removeAt(0);
    }
    
    // Add items from purchase - the API returns purchase records with items array
    if (purchase.items && Array.isArray(purchase.items)) {
      purchase.items.forEach((item: any, index: number) => {
        console.log(`Processing purchase item ${index}:`, item);
        
        // Enhance item with purchase-level data for context
        const enhancedItem = {
          ...item,
          purchaseId: purchase.purchaseId, // API consistently uses purchaseId
          purchaseDate: purchase.invoiceDate,
          supplierId: purchase.supplierId,
          supplierName: purchase.supplierName || purchase.supplier?.name || 'Unknown Supplier'
        };
        
        const formGroup = this.createItemFormGroup(enhancedItem);
        this.itemsArray.push(formGroup);
        console.log(`Added form group ${index}:`, formGroup.value);
      });
    } else {
      console.error('No items found in purchase data or items is not an array');
    }
    
    // CRITICAL FIX: Force supplierName into the form
    console.log('Direct supplierName value before form patch:', purchase.supplierName);
    console.log('Supplier.name value before form patch:', purchase.supplier?.name);
    
    // Force the supplier name to a reasonable value if it's undefined
    const effectiveSupplierName = purchase.supplierName || purchase.supplier?.name || `Supplier ID: ${purchase.supplierId}`;
    console.log('Effective supplier name for form:', effectiveSupplierName);
    
    // Map purchase data to form - ensure we use the exact field names from API
    this.returnForm.patchValue({
      originalPurchaseId: purchase.purchaseId, // API consistently uses purchaseId
      supplierId: purchase.supplierId,
      // Force the supplier name directly rather than relying on indirect binding
      supplierName: effectiveSupplierName
    });
    
    // Force direct set on supplierName control for maximum reliability
    const supplierNameControl = this.returnForm.get('supplierName');
    if (supplierNameControl) {
      console.log('Setting supplier name directly on form control:', effectiveSupplierName);
      supplierNameControl.setValue(effectiveSupplierName);
      supplierNameControl.markAsDirty();
      supplierNameControl.updateValueAndValidity();
    }
    
    // Force form refresh and change detection
    this.cdr.detectChanges();
    
    // Enhanced debugging for form controls
    console.log('%c FORM VALUES AFTER MAPPING', 'background: purple; color: white; font-size: 16px');
    console.log('Updated form values:', this.returnForm.value);
    console.log('Item array length:', this.itemsArray.length);
    
    // Detailed logging of each item's form controls
    this.itemsArray.controls.forEach((control, index) => {
      console.log(`Item ${index} form group:`, control);
      console.log(`Item ${index} form values:`, control.value);
      console.log(`Item ${index} purchase price:`, control.get('purchasePrice')?.value);
      console.log(`Item ${index} MRP:`, control.get('mrpPerItem')?.value);
      console.log(`Item ${index} quantity:`, control.get('originalQuantity')?.value);
    });
    
    // Check if any form controls have missing values and log them for debugging
    setTimeout(() => {
      this.itemsArray.controls.forEach((control: any) => {
        const formGroup = control as FormGroup;
        
        // Just log any missing values to help with debugging
        if (!formGroup.get('purchasePrice')?.value) {
          console.log('Warning: Missing purchase price for item:', formGroup.get('medicineName')?.value);
        }
        if (!formGroup.get('mrpPerItem')?.value) {
          console.log('Warning: Missing MRP for item:', formGroup.get('medicineName')?.value);
        }
        
        this.cdr.detectChanges();
      });
    }, 500);
    
    // Trigger a manual calculation for all items to ensure values are displayed
    setTimeout(() => {
      this.itemsArray.controls.forEach((control, index) => {
        const formGroup = control as FormGroup;
        const returnQty = formGroup.get('returnQuantity')?.value || 0;
        if (returnQty > 0) {
          this.calculateReturnValue(formGroup, returnQty);
        }
        console.log(`Item ${index} values:`, formGroup.value);
      });
      this.calculateTotalReturnAmount();
    }, 100);
  }

  createItemFormGroup(item: any): FormGroup {
    // Log raw data for debugging API structure
    console.log('%c ITEM DATA STRUCTURE', 'background: red; color: white; font-size: 16px');
    console.log('Raw purchase item data:', item);
    console.log('Full item object dump:', JSON.stringify(item, null, 2));
    console.log('All item properties:', Object.keys(item));
    
    // Direct data access from API response based on the actual structure shared by the user
    // Using known field names from the actual API response
    
    // Extract totalReceivedQuantity exactly as in API response
    let quantity = 0;
    if (typeof item.totalReceivedQuantity === 'number') {
      quantity = item.totalReceivedQuantity;
    } else if (item.packQuantity && item.itemsPerPack) {
      // Fallback to calculated quantity if needed
      quantity = (item.packQuantity + (item.freePackQuantity || 0)) * (item.itemsPerPack || 1);
    }
    console.log(`Item quantity set to ${quantity} from:`, {
      totalReceivedQuantity: item.totalReceivedQuantity,
      packQuantity: item.packQuantity,
      freePackQuantity: item.freePackQuantity,
      itemsPerPack: item.itemsPerPack
    });
    
    // Extract purchase cost per pack exactly as in API response
    let purchasePrice = 0;
    if (typeof item.purchaseCostPerPack === 'number' && item.purchaseCostPerPack > 0) {
      purchasePrice = item.purchaseCostPerPack;
      console.log(`Using purchaseCostPerPack: ${purchasePrice}`);
    } else if (item.lineItemTotalAmount && quantity > 0) {
      // Fallback: Calculate unit price from total
      purchasePrice = item.lineItemTotalAmount / quantity;
      console.log(`Calculated price from total: ${purchasePrice}`);
    }
    
    // Extract MRP exactly as in API response
    let mrpPerItem = 0;
    if (typeof item.mrpPerItem === 'number' && item.mrpPerItem > 0) {
      mrpPerItem = item.mrpPerItem;
      console.log(`Using mrpPerItem: ${mrpPerItem}`);
    }
    
    // Essential fields with fallbacks
    const medicineId = item.medicineId || item.productId || item.id || '';
    const medicineName = item.medicineName || item.productName || item.name || this.getMedicineName(medicineId);
    const batchNo = item.batchNo || item.batchNumber || item.batch || '001';
    const expiryDate = item.expiryDate || null;
    
    // Map financial values directly from the API response
    const lineItemTotalAmount = typeof item.lineItemTotalAmount === 'number' ? item.lineItemTotalAmount : 
                               (purchasePrice * quantity) || 0;
    const lineItemTaxableAmount = typeof item.lineItemTaxableAmount === 'number' ? item.lineItemTaxableAmount : 0;
    const lineItemTaxAmount = typeof item.lineItemTaxAmount === 'number' ? item.lineItemTaxAmount : 0;
    const lineItemDiscountAmount = typeof item.lineItemDiscountAmount === 'number' ? item.lineItemDiscountAmount : 0;
    const discountPercentage = typeof item.discountPercentage === 'number' ? item.discountPercentage : 0;
    const taxRate = typeof item.taxRateApplied === 'number' ? item.taxRateApplied : 
                  (typeof item.taxRate === 'number' ? item.taxRate : 0);
    
    console.log('Final calculated values for form:', {
      medicineId,
      medicineName,
      batchNo,
      quantity,
      purchasePrice,
      mrpPerItem,
      lineItemTotalAmount
    });
    
    console.log(`Creating form controls with API values: quantity=${quantity}, price=${purchasePrice}, mrp=${mrpPerItem}`);
    
    const formGroup = this.fb.group({
      medicineId: [medicineId, Validators.required],
      medicineName: [medicineName],
      batchNo: [batchNo, Validators.required],
      originalQuantity: [quantity], // Use API quantity
      purchasePrice: [purchasePrice], // Use API purchase price 
      returnQuantity: [0, [
        Validators.required, 
        Validators.min(1), 
        Validators.max(quantity)
      ]],
      returnValue: [0],
      baseReturnValue: [0], // Added for tax calculation base value
      cgst: [0], // Added for CGST amount
      sgst: [0], // Added for SGST amount
      mrpPerItem: [mrpPerItem], // Use API MRP value
      expiryDate: [expiryDate],
      taxProfileId: [item.taxProfileId || ''],
      taxRate: [taxRate],
      discountPercentage: [discountPercentage],
      lineItemTaxableAmount: [lineItemTaxableAmount],
      lineItemTaxAmount: [lineItemTaxAmount],
      lineItemTotalAmount: [lineItemTotalAmount],
      // Additional fields for better tracking
      packQuantity: [item.packQuantity || 0],
      freePackQuantity: [item.freePackQuantity || 0],
      itemsPerPack: [item.itemsPerPack || 1],
      lineItemDiscountAmount: [lineItemDiscountAmount]
    });
    
    // Set up value change listeners for automatic calculations
    formGroup.get('returnQuantity')?.valueChanges.subscribe((returnQty: number | null) => {
      if (returnQty !== null && returnQty !== undefined && returnQty >= 0) {
        this.calculateReturnValue(formGroup, returnQty);
        this.calculateTotalReturnAmount();
      }
    });
    
    return formGroup;
  }
  
  // Helper method to get medicine name from ID
  getMedicineName(medicineId: string): string {
    if (!medicineId) return 'Unknown Medicine';
    
    // Try to find in loaded medicines first
    const medicine = this.medicines.find(m => m.id === medicineId || m.medicineId === medicineId);
    if (medicine) return medicine.name;
    
    // If we couldn't find it, search by the ID prefix (first 8 chars)
    if (medicineId.length > 8) {
      const idPrefix = medicineId.substring(0, 8);
      const matchingMedicine = this.medicines.find(m => 
        (m.id && m.id.startsWith(idPrefix)) || 
        (m.medicineId && m.medicineId.startsWith(idPrefix)));
      if (matchingMedicine) return matchingMedicine.name;
    }
    
    return `Medicine ID: ${medicineId.substring(0, 8)}`;
  }
  
  // Calculate return value when return quantity changes with tax handling
  calculateReturnValue(formGroup: FormGroup, returnQuantity: number): void {
    // Skip calculation if no return quantity
    if (!returnQuantity || returnQuantity <= 0) {
      formGroup.patchValue({ returnValue: 0, cgst: 0, sgst: 0 });
      return;
    }
    
    // Get original purchase and tax details
    const purchasePrice = formGroup.get('purchasePrice')?.value || 0;
    const originalQuantity = formGroup.get('originalQuantity')?.value || 1;
    const lineItemTotalAmount = formGroup.get('lineItemTotalAmount')?.value || 0;
    const taxProfileId = formGroup.get('taxProfileId')?.value;
    const taxRate = formGroup.get('taxRate')?.value || 0;
    // Get the GST type (assume EXCLUSIVE if not specified)
    const gstType = this.selectedPurchase?.gstType || 'EXCLUSIVE';
    
    console.log('Tax profile info:', { taxProfileId, taxRate, gstType });
    
    // Calculate net amount per unit (without tax for exclusive, with tax for inclusive)
    let netAmountPerUnit = 0;
    let baseAmountPerUnit = 0;
    
    if (lineItemTotalAmount > 0 && originalQuantity > 0) {
      // The lineItemTotalAmount already includes tax for both GST types
      netAmountPerUnit = lineItemTotalAmount / originalQuantity;
      
      // For EXCLUSIVE GST, we need to calculate the base amount without tax
      if (gstType === 'EXCLUSIVE' && taxRate > 0) {
        // Formula: baseAmount = netAmount / (1 + taxRate/100)
        baseAmountPerUnit = netAmountPerUnit / (1 + taxRate / 100);
      } else {
        // For INCLUSIVE or no tax, base amount equals net amount
        baseAmountPerUnit = netAmountPerUnit;
      }
    } else if (purchasePrice > 0) {
      // Fallback to purchase price if line item total is not available
      // For EXCLUSIVE, assume purchasePrice is already the base price without tax
      baseAmountPerUnit = purchasePrice;
      
      if (gstType === 'EXCLUSIVE' && taxRate > 0) {
        // Calculate the net amount including tax
        netAmountPerUnit = baseAmountPerUnit * (1 + taxRate / 100);
      } else {
        // For INCLUSIVE or no tax, net amount equals base amount
        netAmountPerUnit = baseAmountPerUnit;
      }
    }
    
    // Calculate base and net values for return quantity
    const baseReturnValue = baseAmountPerUnit * returnQuantity;
    let netReturnValue = netAmountPerUnit * returnQuantity;
    
    // Calculate individual tax components
    let cgst = 0;
    let sgst = 0;
    
    if (taxProfileId && taxProfileId !== 'N/A' && taxRate > 0) {
      // Calculate tax amount based on base value
      const totalTaxAmount = baseReturnValue * (taxRate / 100);
      
      // Split GST equally between CGST and SGST
      cgst = totalTaxAmount / 2;
      sgst = totalTaxAmount / 2;
      
      // For INCLUSIVE GST, total return value is baseReturnValue + tax
      // For EXCLUSIVE GST, total return value is already calculated as netReturnValue
      if (gstType === 'INCLUSIVE') {
        netReturnValue = baseReturnValue + totalTaxAmount;
      }
      
      console.log('Tax calculation for return:', {
        gstType,
        baseReturnValue,
        taxRate,
        totalTaxAmount,
        cgst,
        sgst,
        netReturnValue
      });
    } else {
      console.log('No tax applied to return value calculation');
    }
    
    // Round values for display
    const roundedReturnValue = Math.round(netReturnValue * 100) / 100;
    const roundedBaseValue = Math.round(baseReturnValue * 100) / 100;
    const roundedCgst = Math.round(cgst * 100) / 100;
    const roundedSgst = Math.round(sgst * 100) / 100;
    
    // Update the form with all calculated values
    formGroup.patchValue({ 
      returnValue: roundedReturnValue,
      baseReturnValue: roundedBaseValue,
      cgst: roundedCgst,
      sgst: roundedSgst 
    });
    
    console.log('Return Value Calculation:', {
      returnQuantity,
      purchasePrice,
      originalQuantity,
      lineItemTotalAmount,
      gstType,
      baseAmountPerUnit,
      netAmountPerUnit,
      baseReturnValue: roundedBaseValue,
      cgst: roundedCgst,
      sgst: roundedSgst,
      netReturnValue: roundedReturnValue
    });
  }
  // Handle return quantity change from input
  onReturnQuantityChange(formGroup: FormGroup, event: any): void {
    const returnQuantity = parseInt(event.target.value) || 0;
    const maxQuantity = formGroup.get('originalQuantity')?.value || 0;
    
    // Validate return quantity
    if (returnQuantity > maxQuantity) {
      event.target.value = maxQuantity;
      formGroup.patchValue({ returnQuantity: maxQuantity });
      this.calculateReturnValue(formGroup, maxQuantity);
    } else {
      formGroup.patchValue({ returnQuantity: returnQuantity });
      this.calculateReturnValue(formGroup, returnQuantity);
    }
    
    // Recalculate total
    this.calculateTotalReturnAmount();
  }
  
  // Calculate total return amount for all items with tax breakdown
  calculateTotalReturnAmount(): void {
    let totalReturnAmount = 0;
    let totalBaseAmount = 0;
    let totalCGST = 0;
    let totalSGST = 0;
    
    this.itemsArray.controls.forEach(control => {
      const returnValue = control.get('returnValue')?.value || 0;
      const baseValue = control.get('baseReturnValue')?.value || 0;
      const cgst = control.get('cgst')?.value || 0;
      const sgst = control.get('sgst')?.value || 0;
      
      totalReturnAmount += returnValue;
      totalBaseAmount += baseValue;
      totalCGST += cgst;
      totalSGST += sgst;
    });
    
    // Round values for display
    const roundedTotal = Math.round(totalReturnAmount * 100) / 100;
    const roundedBase = Math.round(totalBaseAmount * 100) / 100;
    const roundedCGST = Math.round(totalCGST * 100) / 100;
    const roundedSGST = Math.round(totalSGST * 100) / 100;
    
    // Update the form with total return amount and tax breakdown
    this.returnForm.patchValue({ 
      totalReturnAmount: roundedTotal,
      totalBaseAmount: roundedBase,
      totalCGST: roundedCGST,
      totalSGST: roundedSGST
    });
    
    // Force change detection to update UI
    this.cdr.detectChanges();
    
    // Enhanced debug info for tracking total calculations with tax breakdown
    console.log('Total return amount calculation:', {
      totalReturnAmount: roundedTotal,
      totalBaseAmount: roundedBase,
      totalCGST: roundedCGST,
      totalSGST: roundedSGST,
      formValue: this.returnForm.get('totalReturnAmount')?.value,
      itemsCount: this.itemsArray.length,
      itemsWithValues: this.itemsArray.controls.filter(c => (c.get('returnValue')?.value || 0) > 0).length,
      itemsWithTax: this.itemsArray.controls.filter(c => 
        (c.get('cgst')?.value || 0) > 0 || (c.get('sgst')?.value || 0) > 0
      ).length
    });
  }

  clearItemsArray(): void {
    while (this.itemsArray.length !== 0) {
      this.itemsArray.removeAt(0);
    }
  }

  // Load medicines for reference
  loadMedicines(): void {
    this.inventoryService.getMedicines()
      .subscribe({
        next: (medicines) => {
          this.medicines = medicines;
          console.log('Medicines loaded:', medicines.length);
        },
        error: (error) => {
          console.error('Error loading medicines:', error);
        }
      });
  }

  onSubmit(): void {
    if (this.returnForm.invalid) {
      this.markFormGroupTouched(this.returnForm);
      return;
    }

    if (this.itemsArray.length === 0) {
      this.toastService.showError('Please select at least one item to return');
      return;
    }

    // Check if any items have return quantity > 0
    const hasItemsToReturn = this.itemsArray.controls.some(
      control => control.get('returnQuantity')?.value > 0
    );

    if (!hasItemsToReturn) {
    
    totalReturnAmount += returnValue;
    totalBaseAmount += baseValue;
    totalCGST += cgst;
    totalSGST += sgst;
  });
  
  // Round values for display
  const roundedTotal = Math.round(totalReturnAmount * 100) / 100;
  const roundedBase = Math.round(totalBaseAmount * 100) / 100;
  const roundedCGST = Math.round(totalCGST * 100) / 100;
  const roundedSGST = Math.round(totalSGST * 100) / 100;
  
  // Update the form with total return amount and tax breakdown
  this.returnForm.patchValue({ 
    totalReturnAmount: roundedTotal,
    totalBaseAmount: roundedBase,
    totalCGST: roundedCGST,
    totalSGST: roundedSGST
  });
  
  // Force change detection to update UI
  this.cdr.detectChanges();
  
  // Enhanced debug info for tracking total calculations with tax breakdown
  console.log('Total return amount calculation:', {
    totalReturnAmount: roundedTotal,
    totalBaseAmount: roundedBase,
    totalCGST: roundedCGST,
    totalSGST: roundedSGST,
    formValue: this.returnForm.get('totalReturnAmount')?.value,
    itemsCount: this.itemsArray.length,
    itemsWithValues: this.itemsArray.controls.filter(c => (c.get('returnValue')?.value || 0) > 0).length,
    itemsWithTax: this.itemsArray.controls.filter(c => 
      (c.get('cgst')?.value || 0) > 0 || (c.get('sgst')?.value || 0) > 0
    ).length
  });
}

clearItemsArray(): void {
  while (this.itemsArray.length !== 0) {
    this.itemsArray.removeAt(0);
  }
}

// Load medicines for reference
loadMedicines(): void {
  this.inventoryService.getMedicines()
    .subscribe({
      next: (medicines) => {
        this.medicines = medicines;
        console.log('Medicines loaded:', medicines.length);
      },
      error: (error) => {
        console.error('Error loading medicines:', error);
      }
    });
}

onSubmit(): void {
  if (this.returnForm.invalid) {
    this.markFormGroupTouched(this.returnForm);
    return;
  }

  if (this.itemsArray.length === 0) {
    this.toastService.showError('Please select at least one item to return');
    return;
  }

  // Check if any items have return quantity > 0
  const hasItemsToReturn = this.itemsArray.controls.some(
    control => control.get('returnQuantity')?.value > 0
  );

  if (!hasItemsToReturn) {
            this.toastService.showError(
              `Cannot return more items than purchased. Medicine: ${firstInvalidItem.medicineName}, ` +
              `Maximum allowed: ${firstInvalidItem.originalQuantity}, ` +
              `Attempted: ${firstInvalidItem.returnQuantity}`
            );
          } else if (error?.error?.message) {
            // Display the server's error message if available
            this.toastService.showError(error.error.message);
          } else {
            // Show custom message for HTTP 500 specifically related to returns
            this.toastService.showError(
              'Invalid return quantities. Please ensure you are not returning more items than were purchased.'
            );
          }
        } else {
          // Default error message for other errors
          this.toastService.showError('Failed to create purchase return. Please try again.');
        }
      
      if (returnQuantity > originalQuantity) {
        invalidItems.push({
          medicineName,
          originalQuantity,
          returnQuantity
        });
      }
    });
    
    return invalidItems;
  }
  }

  // Helper method to mark all form controls as touched
  markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach(control => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }
  
  /**
   * Reset the form to its initial state
   */
  resetForm(): void {
    // Clear the selected purchase
    this.selectedPurchase = null;
    
    // Reset the search control
    this.searchControl.reset('');
    this.purchaseSearchText = '';
    this.filteredPurchases = [];
    
    // Reset the form
    this.initForm();
    
    this.toastService.showInfo('Form has been reset');
  }
  
  // Cancel and go back to list
  cancel(): void {
    this.router.navigate(['/inventory/returns']);
  }
  
  // Check if there are items to return
  hasItemsToReturn(): boolean {
    const result = this.itemsArray.controls.some(
      control => (control.get('returnQuantity')?.value || 0) > 0
    );
    // Debug log for button enablement
    console.log('Button enablement status:', {
      formValid: !this.returnForm.invalid,
      notLoading: !this.isLoading,
      hasItems: this.itemsArray.length > 0,
      hasItemsToReturn: result,
      buttonEnabled: !this.returnForm.invalid && !this.isLoading && this.itemsArray.length > 0 && result
    });
    
    // If form is invalid, log which controls are invalid
    if (this.returnForm.invalid) {
      const invalidControls: Record<string, {errors: any, value: any}> = {};
      Object.keys(this.returnForm.controls).forEach(key => {
        const control = this.returnForm.get(key);
        if (control && control.invalid) {
          invalidControls[key] = {
            errors: control.errors,
            value: control.value
          };
        }
      });
      console.log('Invalid controls:', invalidControls);
    }
    
    return result;
  }
  
  // Helper method to get the count of items that have a return quantity > 0
  getItemsToReturnCount(): number {
    return this.itemsArray.controls.filter(control => {
      const returnQty = control.get('returnQuantity')?.value || 0;
      return returnQty > 0;
    }).length;
  }
  
  // Helper method to check if any items have tax profiles
  hasTaxItems(): boolean {
    if (!this.itemsArray || this.itemsArray.length === 0) return false;
    
    return this.itemsArray.controls.some(control => {
      const taxProfileId = control.get('taxProfileId')?.value;
      return taxProfileId && taxProfileId !== 'N/A';
    });
  }
  
  // Simplified helper method to check if any items can be returned
  hasAnyItemToReturn(): boolean {
    if (!this.itemsArray || this.itemsArray.length === 0) return false;
    
    const hasItems = this.itemsArray.controls.some(
      control => (control.get('returnQuantity')?.value || 0) > 0
    );
    
    console.log('hasAnyItemToReturn check:', { 
      hasItems,
      itemsLength: this.itemsArray.length,
      itemsWithQuantity: this.itemsArray.controls
        .filter(c => (c.get('returnQuantity')?.value || 0) > 0).length
    });
    
    return hasItems;
  }
}
